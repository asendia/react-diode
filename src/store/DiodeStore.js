/**
 * @flow
 */
import objectAssign from 'object-assign';
import find from 'lodash.find';
import DiodeNetworkLayer from '../network/DiodeNetworkLayer';
import DiodeQueryTypes from '../query/DiodeQueryTypes';
import resolvePendingQueries from '../query/resolvePendingQueries';
import filterBatchQuery from '../query/filterBatchQuery';
import resolveBatchQuery from '../query/resolveBatchQuery';

import {
  getQueryRequests
} from '../query/DiodeQueryRequest';

import type { DiodeRootContainer } from '../container/DiodeRootContainer';
import type {
  BatchQueryDefinition,
  NetworkLayer
} from '../tools/DiodeTypes';
import type {
  DiodeQueryRequest
} from '../query/DiodeQueryRequest';

class DiodeStore {
  _networkLayer: DiodeNetworkLayer;

  _batchQueryEnabled: boolean;

  _batchQuery: BatchQueryDefinition;

  constructor() {
    this._batchQueriesEnabled = false;
    this._networkLayer = new DiodeNetworkLayer();
  }

  /**
   * @public
   */
  injectNetworkLayer(
    networkLayer: NetworkLayer
  ): void {
    this._networkLayer.injectNetworkLayer(networkLayer);
  }

  /**
   * @public
   */
  useBatchQuery(
    batchQuery: BatchQueryDefinition
  ): void {
    /* istanbul ignore else */
    if (batchQuery) {
      this._batchQueryEnabled = true;
      this._batchQuery = batchQuery;
    }
  }

  /**
   * @public
   *
   * Send queries via network layer bypassing internal cache. Note that the
   * server may respond with 304 status but it's not actually an internal
   * cached response
   */
  forceFetch(
    RootContainer: DiodeRootContainer,
    options: any
  ): Promise {
    const queries = getQueryRequests(RootContainer);

    return this._fetchQueries(queries, options).then(response => {
      // Convert diode response as root container props
      const { map: queryMap } = RootContainer.query.getContainerQuery();
      return Object.keys(queryMap).reduce((props, key) => {
        props[key] = response[queryMap[key].type];
        return props;
      }, {});
    });
  }

  /**
   * Recursively fetch over query dependency, starting with query with no
   * dependency, and build response moving up
   *
   * TODO:
   *  - All DiodeQueryRequest should contain pending property for filtering
   *    instead of using query.dependencies which is not available in normal
   *    QueryRequest
   */
  _fetchQueries(
    allQueries: Array<DiodeQueryRequest>,
    options: any = {}
  ): Promise {
    // We need to store unmodified initial queries before filtered
    // into batch query so we can use their resolve function when resolving
    // response from batch query
    const pendingQueries = allQueries.filter(query => query.dependencies);
    const initialQueries = allQueries.filter(query => !query.dependencies);
    let queries = initialQueries;

    if (this._batchQueryEnabled) {
      queries = filterBatchQuery(queries, this._batchQuery);
    }

    return this._networkLayer.sendQueries(queries, options)
    .then(queryResponseMap => {
      const responseMap = Object.keys(queryResponseMap)
      .reduce((map, type) => {
        const queryResponse = queryResponseMap[type];
        const query = find(queries, { type });

        if (type === DiodeQueryTypes.BATCH) {
          // BatchQuery returns multiple response at once as single object,
          // we need to merge initial response with response generated by
          // batch query response resolution
          const batchQueryResponseMap = resolveBatchQuery(
            query.resolve(queryResponse, options),
            initialQueries,
            options
          );
          objectAssign(map, batchQueryResponseMap);
        } else {
          map[type] = query.resolve(
            queryResponse,
            query.fragment,
            options
          );
        }

        return map;
      }, {});

      if (pendingQueries.length > 0) {
        const nextQueries = resolvePendingQueries(pendingQueries, responseMap);
        return this._fetchQueries(nextQueries, options)
        .then(nextResponseMap => {
          return objectAssign(responseMap, nextResponseMap);
        });
      }

      return responseMap;
    });
  }
}

module.exports = new DiodeStore();
